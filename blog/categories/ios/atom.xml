<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 大众点赞 - 沉迷的大多数]]></title>
  <link href="http://like.lessfun.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://like.lessfun.com/"/>
  <updated>2014-09-22T11:17:04+08:00</updated>
  <id>http://like.lessfun.com/</id>
  <author>
    <name><![CDATA[TinyToy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS App 崩溃报告符号化，.ips崩溃报告文件分析]]></title>
    <link href="http://like.lessfun.com/blog/2014/09/22/symbolicating-ios-app-crash-reports/"/>
    <updated>2014-09-22T10:22:22+08:00</updated>
    <id>http://like.lessfun.com/blog/2014/09/22/symbolicating-ios-app-crash-reports</id>
    <content type="html"><![CDATA[<p>本文为翻译整理。来源: <a href="http://stackoverflow.com/questions/1460892/symbolicating-iphone-app-crash-reports">Symbolicating iPhone App Crash Reports</a></p>

<p>对于App的崩溃分析，一般有两种情形：</p>

<ul>
<li>App在本机构建、打包（所以本机已经有了对应的符号表）</li>
<li>App在别的机器上构建、打包（需要下载.dSYM符号文件）</li>
</ul>


<!--more-->


<h3>1. App在本机构建、打包</h3>

<p>由于我们本机在构建过程中已经生成了符号信息，所以符号化崩溃文件的过程很简单：</p>

<ol>
<li>重命名崩溃报告文件为<code>.crash</code>后缀（对于从Windows导出的崩溃文件适用）</li>
<li>打开<code>Xcode</code> &ndash; <code>Organizer</code> &ndash; <code>Device Logs</code></li>
<li>点击<code>import</code>，导入.crash文件</li>
</ol>


<p>这时就可以看到符号化了的崩溃日记。</p>

<h3>2. App在别的机器构建、打包</h3>

<p>首先我们从构建机器下载对应的app和.dSYM文件，为了结构清晰，可以和.crash文件放在同一个目录，如<code>CrashReport</code>。接下来需要通过终端完成：</p>

<ol>
<li>用<code>cd</code>命令切换到<code>CrashReport</code>目录</li>
<li>输入<code>atos -arch armv7  -o 'APPNAME.app'/'APPNAME'</code></li>
<li>这时可以看到光标闪动，被atos命令控制住了。</li>
<li>输入崩溃的堆栈地址，如：<code>0x0003b508</code>，可以看到打印出来的错误信息，见下面：</li>
</ol>


<p>``` bash</p>

<p>  MyMac:CrashReport MyMac$ atos -arch armv7 -o &lsquo;myapp.app&rsquo;/&lsquo;myapp&rsquo;
  0x000cdc32 ;崩溃地址
  +[UMANUtil sha1WithData:] (in kiwi) + 86 ;对应的代码</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective C提高开发效率的10个实用的宏定义]]></title>
    <link href="http://like.lessfun.com/blog/2014/09/18/10-useful-macros-in-objective-c-develop/"/>
    <updated>2014-09-18T15:59:36+08:00</updated>
    <id>http://like.lessfun.com/blog/2014/09/18/10-useful-macros-in-objective-c-develop</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/develop/lessfun_c_macros.gif" title="&lsquo;c macros&rsquo; &lsquo;c macros&rsquo;" ></p>

<p>在类C语言中，宏的存在一直具有争议性，支持者觉得宏可以大大提高效率，使代码更简洁，用起来得心应手；反对者则认为，宏使得变量失去了类型，并且难以调试，降低了代码的可读性。这里我不准备探讨宏本身的意义，只想说明，在使用Objective C开发iOS项目时，这10个实用的宏，可以大大地提高你的开发效率，并且不影响可读性。</p>

<!--more-->


<p>Objective C的语法十分冗余，命名也是长不忍睹，虽然有自动补全，但是写起来还是很不方便，而宏定义就是为解决这些烦恼而生。如果你是宏定义一生黑，也可以用函数替换。</p>

<p>以下宏定义保存在一个文件<code>YourMacro.h</code>中，并且在预编译头文件xx-Prefix.pch中#import，就可以在全局工程中使用了。</p>

<h3>Device Info</h3>

<p>判断设备类型：</p>

<p>``` c</p>

<pre><code>#define IsIPad   (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
#define IsIPhone (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
</code></pre>

<p>```</p>

<h3>System Version</h3>

<p>获取系统版本信息：</p>

<p>``` c</p>

<pre><code>#define SystemVersionLessThan(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)
</code></pre>

<p>```</p>

<p>例如，判断iOS版本，是否低于iOS7：</p>

<p>``` c</p>

<pre><code>if (SystemVersionLessThan(@"7.0")) {
    return;
}
</code></pre>

<p>```</p>

<h3>UI</h3>

<p>判断是否为高清屏：</p>

<p>``` c</p>

<pre><code>#define IsRetina  ([[UIScreen mainScreen] respondsToSelector:@selector(scale)] &amp;&amp; [[UIScreen mainScreen] scale] &gt;= 2)
</code></pre>

<p>```</p>

<h3>Color</h3>

<p>``` c</p>

<pre><code>#define Color_RGB(r, g, b) [UIColor colorWithRed:r / 255.0 green:g / 255.0 blue:b / 255.0 alpha:1]
#define Color_RGBA(r, g, b, a) [UIColor colorWithRed:r / 255.0 green:g / 255.0 blue:b / 255.0 alpha:a]

//用法
view.backgroundColor = Color_RGB(0, 0, 0);
</code></pre>

<p>```</p>

<h3>NSString</h3>

<p>``` c</p>

<pre><code>#define NSStringFromInt(d) [NSString stringWithFormat:@"%d", (d)]
#define NSStringFromLong(d) [NSString stringWithFormat:@"%lld", (d)]
#define NSStringConcat(str1, str2) [NSString stringWithFormat:@"%@%@", (str1), (str2)]
#define NSStringFromNSData(data) [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]
#define NSDataFromNSString(str) [str dataUsingEncoding:NSUTF8StringEncoding]
</code></pre>

<p>```</p>

<h3>Number</h3>

<p>``` c</p>

<pre><code>//比较浮点数
#define FloatEqual(f1, f2)     ( fabs( (f1) - (f2) ) &lt; 0.0001 )
//使数值在上下限内
#define MID(x, y, z)                    ( y &lt; x ? x : (z &lt; y ? z : y) )
</code></pre>

<p>```</p>

<h3>Notification</h3>

<p>``` c</p>

<pre><code>/**
 * 通知声明
 */
#define N_Dec(notification) extern NSString * const notification

/**
 * 通知定义
 */
#define N_Def(notification) NSString * const notification = @#notification
</code></pre>

<p>```</p>

<h3>Localization</h3>

<p>``` c</p>

<pre><code>#define L(key) NSLocalizedString(key, nil)
//用法
label.text = L(@"Hello");
</code></pre>

<p>```</p>

<h3>Debug &amp; Log</h3>

<p>NSLog默认会在Debug和Release版都打印，如果希望Release版本不打印Log：</p>

<p>``` c</p>

<pre><code>#ifdef DEBUG
    #define MyLog( s, ... ) NSLog( @"&lt;%@:%d&gt; %@", [[NSString stringWithUTF8String:__FILE__] lastPathComponent], __LINE__,  [NSString stringWithFormat:(s), ##__VA_ARGS__] )
#else
    #define MyLog( s, ... )
#endif
</code></pre>

<p>```</p>

<h3>App</h3>

<p>``` c</p>

<pre><code>/**
 * 是否内测版本
 */
#define IsInternalApp ([[NSBundle mainBundle].bundleIdentifier isEqualToString:@"com.inc.enterprise.proj"])
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
