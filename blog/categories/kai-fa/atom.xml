<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 开发 | 大众点赞 - 沉迷的大多数]]></title>
  <link href="http://like.lessfun.com/blog/categories/kai-fa/atom.xml" rel="self"/>
  <link href="http://like.lessfun.com/"/>
  <updated>2014-10-17T13:30:55+08:00</updated>
  <id>http://like.lessfun.com/</id>
  <author>
    <name><![CDATA[TinyToy]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最受欢迎的iOS开源库，以及找到最热门开源框架的方法]]></title>
    <link href="http://like.lessfun.com/blog/2014/10/16/the-most-popular-ios-open-source-framework/"/>
    <updated>2014-10-16T10:28:20+08:00</updated>
    <id>http://like.lessfun.com/blog/2014/10/16/the-most-popular-ios-open-source-framework</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/develop/lessfun_ios_open_source_github.png" title="&lsquo;ios open source projects on github&rsquo;" ></p>

<p>&ldquo;我就是要重复造轮子"，几乎每个程序员都这么想，一方面是由于程序员觉得自己造出来的轮子才是世界上最完美的轮子，无论是接口设计、遍历命名、代码对齐还是文档注释，一切看起来都那么顺眼。<br/>
另一方面，则是程序员不知道别人已经造出来了功能类似但质量更好的轮子。</p>

<p>本文列举了在iOS开发届最受欢迎、用户最多的开源框架，并授人以渔地提供了找到最热门的开源框架的方法。旨在帮助iOS开发者发现更大的轮子，避免重复造轮子。</p>

<p>当然，你可以自己开发一个更好用更受欢迎的开源库。</p>

<!--more-->


<h3>最受欢迎的iOS开源库</h3>

<p>开发iOS App，总是避免不了这些模块：<code>网络检测</code>，<code>网络访问</code>，<code>文件解析</code>，<code>数据存储</code>，<code>进度显示</code>，<code>统计上报</code>，等等。数一下，如果每个模块都得自己重新写代码，那得耗费多少时间。</p>

<p>好消息是，上述所有的模块，在网上都有很优秀的开源库可以使用，而且基本都提供了CocoaPods的集成方法，最大程度简化了iOS开发者的代码量。</p>

<h4>网络检测：Reachability</h4>

<p>这是苹果官方提供的开源代码，用于检测设备的网络状态，判断网络是否可用，当前的网络类型是2G/3G，还是WiFi。<br/>
主页：<a href="https://developer.apple.com/library/IOs/samplecode/Reachability/Listings/Reachability_Reachability_h.html">Reachability</a></p>

<h4>网络访问：AFNetworking</h4>

<p>一个轻量级的网络访问库，在GitHub上得到的Star是10000+，可见其受欢迎程度。几乎每个需要访问网络的App，必定都集成了这个开源库。<br/>
主页：<a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a></p>

<h4>数据存储：FMDB</h4>

<p>iOS与Mac OS中对SQLite的封装，简化数据库存储的代码。<br/>
主页：<a href="https://github.com/ccgus/fmdb">https://github.com/ccgus/fmdb</a></p>

<h4>文件解析：JSONKit与RaptureXML</h4>

<p>解析json与xml文件的工具。<br/>
JSONKit主页：<a href="https://github.com/johnezang/JSONKit  ">https://github.com/johnezang/JSONKit  </a>
RaptureXML主页：<a href="https://github.com/ZaBlanc/RaptureXML">https://github.com/ZaBlanc/RaptureXML</a></p>

<h4>进度显示：SVProgressHUD</h4>

<p>简洁好用的状态、进度显示框。<br/>
主页：<a href="https://github.com/TransitApp/SVProgressHUD">https://github.com/TransitApp/SVProgressHUD</a></p>

<h4>网络图片：SDWebImage</h4>

<p>一个UIImageView的扩展，可以支持显示网络上的图片。<br/>
主页：<a href="https://github.com/rs/SDWebImage">https://github.com/rs/SDWebImage</a></p>

<h4>统计上报：友盟</h4>

<p>数据统计、错误上报，推荐使用友盟提供的SDK，同时还提供了用户反馈功能。<br/>
主页：<a href="http://www.umeng.com/">http://www.umeng.com/</a></p>

<h3>找到最热门开源框架的方法</h3>

<h4>Google</h4>

<p>谷歌是一切网站的入口，互联网上的所有数据，基本上都可以通过谷歌找到，而你所需要的只是提供适当的关键字进行搜索。</p>

<h4>Github</h4>

<p>开源库基本上都集中在GitHub，所以可以跳过谷歌，直接在GitHub中搜索。</p>

<h4>CocoaPods Search</h4>

<p>如果使用CocoaPods，那么也可以在pod中搜索。如下：</p>

<p>``` bash</p>

<pre><code>MacBook-Air:develop user$ pod search autolayout
</code></pre>

<p>  &ndash;> AutoLayoutCells (0.4.2)
   AutoLayoutCells makes working with dynamic table view cells easy.
   pod &lsquo;AutoLayoutCells&rsquo;, &lsquo;~> 0.4.2&rsquo;
   &ndash; Homepage: <a href="https://github.com/JRG-Developer/AutoLayoutCells">https://github.com/JRG-Developer/AutoLayoutCells</a>
   &ndash; Source:   <a href="https://github.com/JRG-Developer/AutoLayoutCells.git">https://github.com/JRG-Developer/AutoLayoutCells.git</a>
   &ndash; Versions: 0.4.2, 0.4.1, 0.4.0, 0.3.0, 0.2.1, 0.2.0 [master repo]
   &ndash; Sub specs:   &ndash; AutoLayoutCells/SharedCategories (0.4.2)   &ndash; AutoLayoutCells/TableViewCells (0.4.2)</p>

<p>```</p>

<h4>ios.hew.io</h4>

<p>这是一个网站，收录了iOS、Android、JavaScript相关的开源库，并且按照热门程度给出搜索结果。
主页：<a href="http://ios.hew.io">http://ios.hew.io</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App 崩溃报告符号化，.ips崩溃报告文件分析]]></title>
    <link href="http://like.lessfun.com/blog/2014/09/22/symbolicating-ios-app-crash-reports/"/>
    <updated>2014-09-22T10:22:22+08:00</updated>
    <id>http://like.lessfun.com/blog/2014/09/22/symbolicating-ios-app-crash-reports</id>
    <content type="html"><![CDATA[<p>本文为翻译整理。来源: <a href="http://stackoverflow.com/questions/1460892/symbolicating-iphone-app-crash-reports">Symbolicating iPhone App Crash Reports</a></p>

<p>对于App的崩溃分析，一般有两种情形：</p>

<ul>
<li>App在本机构建、打包（所以本机已经有了对应的符号表）</li>
<li>App在别的机器上构建、打包（需要下载.dSYM符号文件）</li>
</ul>


<!--more-->


<h3>1. App在本机构建、打包</h3>

<p>由于我们本机在构建过程中已经生成了符号信息，所以符号化崩溃文件的过程很简单：</p>

<ol>
<li>重命名崩溃报告文件为<code>.crash</code>后缀（对于从Windows导出的崩溃文件适用）</li>
<li>打开<code>Xcode</code> &ndash; <code>Organizer</code> &ndash; <code>Device Logs</code></li>
<li>点击<code>import</code>，导入.crash文件</li>
</ol>


<p>这时就可以看到符号化了的崩溃日记。</p>

<h3>2. App在别的机器构建、打包</h3>

<p>首先我们从构建机器下载对应的app和.dSYM文件，为了结构清晰，可以和.crash文件放在同一个目录，如<code>CrashReport</code>。接下来需要通过终端完成：</p>

<ol>
<li>用<code>cd</code>命令切换到<code>CrashReport</code>目录</li>
<li>输入<code>atos -arch armv7  -o 'APPNAME.app'/'APPNAME'</code></li>
<li>这时可以看到光标闪动，被atos命令控制住了。</li>
<li>输入崩溃的堆栈地址，如：<code>0x0003b508</code>，可以看到打印出来的错误信息，见下面：</li>
</ol>


<p>``` bash</p>

<p>  MyMac:CrashReport MyMac$ atos -arch armv7 -o &lsquo;myapp.app&rsquo;/&lsquo;myapp&rsquo;
  0x000cdc32 ;崩溃地址
  +[UMANUtil sha1WithData:] (in kiwi) + 86 ;对应的代码</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective C提高开发效率的10个实用的宏定义]]></title>
    <link href="http://like.lessfun.com/blog/2014/09/18/10-useful-macros-in-objective-c-develop/"/>
    <updated>2014-09-18T15:59:36+08:00</updated>
    <id>http://like.lessfun.com/blog/2014/09/18/10-useful-macros-in-objective-c-develop</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/develop/lessfun_c_macros.gif" title="&lsquo;c macros&rsquo; &lsquo;c macros&rsquo;" ></p>

<p>在类C语言中，宏的存在一直具有争议性，支持者觉得宏可以大大提高效率，使代码更简洁，用起来得心应手；反对者则认为，宏使得变量失去了类型，并且难以调试，降低了代码的可读性。这里我不准备探讨宏本身的意义，只想说明，在使用Objective C开发iOS项目时，这10个实用的宏，可以大大地提高你的开发效率，并且不影响可读性。</p>

<!--more-->


<p>Objective C的语法十分冗余，命名也是长不忍睹，虽然有自动补全，但是写起来还是很不方便，而宏定义就是为解决这些烦恼而生。如果你是宏定义一生黑，也可以用函数替换。</p>

<p>以下宏定义保存在一个文件<code>YourMacro.h</code>中，并且在预编译头文件xx-Prefix.pch中#import，就可以在全局工程中使用了。</p>

<h3>Device Info</h3>

<p>判断设备类型：</p>

<p>``` c</p>

<pre><code>#define IsIPad   (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
#define IsIPhone (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
</code></pre>

<p>```</p>

<h3>System Version</h3>

<p>获取系统版本信息：</p>

<p>``` c</p>

<pre><code>#define SystemVersionLessThan(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)
</code></pre>

<p>```</p>

<p>例如，判断iOS版本，是否低于iOS7：</p>

<p>``` c</p>

<pre><code>if (SystemVersionLessThan(@"7.0")) {
    return;
}
</code></pre>

<p>```</p>

<h3>UI</h3>

<p>判断是否为高清屏：</p>

<p>``` c</p>

<pre><code>#define IsRetina  ([[UIScreen mainScreen] respondsToSelector:@selector(scale)] &amp;&amp; [[UIScreen mainScreen] scale] &gt;= 2)
</code></pre>

<p>```</p>

<h3>Color</h3>

<p>``` c</p>

<pre><code>#define Color_RGB(r, g, b) [UIColor colorWithRed:r / 255.0 green:g / 255.0 blue:b / 255.0 alpha:1]
#define Color_RGBA(r, g, b, a) [UIColor colorWithRed:r / 255.0 green:g / 255.0 blue:b / 255.0 alpha:a]

//用法
view.backgroundColor = Color_RGB(0, 0, 0);
</code></pre>

<p>```</p>

<h3>NSString</h3>

<p>``` c</p>

<pre><code>#define NSStringFromInt(d) [NSString stringWithFormat:@"%d", (d)]
#define NSStringFromLong(d) [NSString stringWithFormat:@"%lld", (d)]
#define NSStringConcat(str1, str2) [NSString stringWithFormat:@"%@%@", (str1), (str2)]
#define NSStringFromNSData(data) [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]
#define NSDataFromNSString(str) [str dataUsingEncoding:NSUTF8StringEncoding]
</code></pre>

<p>```</p>

<h3>Number</h3>

<p>``` c</p>

<pre><code>//比较浮点数
#define FloatEqual(f1, f2)     ( fabs( (f1) - (f2) ) &lt; 0.0001 )
//使数值在上下限内
#define MID(x, y, z)                    ( y &lt; x ? x : (z &lt; y ? z : y) )
</code></pre>

<p>```</p>

<h3>Notification</h3>

<p>``` c</p>

<pre><code>/**
 * 通知声明
 */
#define N_Dec(notification) extern NSString * const notification

/**
 * 通知定义
 */
#define N_Def(notification) NSString * const notification = @#notification
</code></pre>

<p>```</p>

<h3>Localization</h3>

<p>``` c</p>

<pre><code>#define L(key) NSLocalizedString(key, nil)
//用法
label.text = L(@"Hello");
</code></pre>

<p>```</p>

<h3>Debug &amp; Log</h3>

<p>NSLog默认会在Debug和Release版都打印，如果希望Release版本不打印Log：</p>

<p>``` c</p>

<pre><code>#ifdef DEBUG
    #define MyLog( s, ... ) NSLog( @"&lt;%@:%d&gt; %@", [[NSString stringWithUTF8String:__FILE__] lastPathComponent], __LINE__,  [NSString stringWithFormat:(s), ##__VA_ARGS__] )
#else
    #define MyLog( s, ... )
#endif
</code></pre>

<p>```</p>

<h3>App</h3>

<p>``` c</p>

<pre><code>/**
 * 是否内测版本
 */
#define IsInternalApp ([[NSBundle mainBundle].bundleIdentifier isEqualToString:@"com.inc.enterprise.proj"])
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
